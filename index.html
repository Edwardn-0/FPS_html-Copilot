<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplayer FPS</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:#000; font-family:sans-serif; }
    #overlay, #mainMenu, #topHUD, #ammo, #health, #caps { position:absolute; z-index:10; }
    #mainMenu { top:50%; left:50%; transform:translate(-50%,-50%); background:#111; padding:20px; border-radius:8px; color:#fff; }
    #overlay { display:none; top:10px; left:10px; color:#fff; }
    #topHUD { top:10px; right:10px; color:#fff; }
    #ammo, #health { bottom:10px; left:10px; color:#fff; }
    #caps { bottom:10px; right:10px; color:#fff; }
  </style>
</head>
<body>
  <div id="mainMenu">
    <h2>Join or Create Room</h2>
    <input id="playerName" placeholder="Name"><br>
    <button id="createRoom">Create Room</button>
    <button id="joinRoom">Join Room</button>
  </div>
  <div id="overlay">
    <h3>Lobby</h3>
    <button id="startGame">Start Game</button>
  </div>
  <div id="topHUD">Kills: <span id="kills">0</span></div>
  <div id="ammo">Ammo: <span id="ammoCount">30</span></div>
  <div id="health">HP: <span id="hp">100</span></div>
  <div id="caps">
    <div>A: <div id="capAFill">0%</div></div>
    <div>B: <div id="capBFill">0%</div></div>
    <div>C: <div id="capCFill">0%</div></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    const SERVER_URL = "wss://your-server-here.onrender.com"; // Render 배포용 WebSocket 주소
    let socket;
    let scene, camera, renderer;
    let ground, captureGroup;
    let world = {};
    let worldSizeX, worldSizeZ;

    init();

    function init(){
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10,10,10);
      scene.add(light);

      ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({ color:0x333333 }));
      ground.rotation.x = -Math.PI/2;
      scene.add(ground);

      captureGroup = new THREE.Group();
      scene.add(captureGroup);

      camera.position.set(0,10,20);
      animate();
    }

    function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function makeChecker(size, squares, c1, c2){
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const step = size / squares;
      for(let y=0;y<squares;y++){
        for(let x=0;x<squares;x++){
          ctx.fillStyle = (x+y)%2===0 ? c1 : c2;
          ctx.fillRect(x*step,y*step,step,step);
        }
      }
      return new THREE.CanvasTexture(canvas);
    }

    function carveMaze(cols, rows){
      // 간단한 더미 맵 생성 (전부 빈칸)
      return Array(rows).fill().map(()=>Array(cols).fill(0));
    }

    function buildWallsFromCells(cells, mat){
      for(let z=0; z<cells.length; z++){
        for(let x=0; x<cells[z].length; x++){
          if(cells[z][x]===1){
            const wall = new THREE.Mesh(new THREE.BoxGeometry(6,6,6), mat);
            wall.position.set(x*6 - worldSizeX/2, 3, z*6 - worldSizeZ/2);
            scene.add(wall);
          }
        }
      }
    }

    function buildMapDOM(){
      world.cols=20;
      world.rows=14;
      world.cell=6;
      worldSizeX=world.cols*world.cell;
      worldSizeZ=world.rows*world.cell;
      ground.material.map=makeChecker(1024,64,'#243c5a','#132a44');
      ground.material.needsUpdate=true;
      ground.geometry.dispose();
      ground.geometry=new THREE.PlaneGeometry(worldSizeX+20, worldSizeZ+20);

      const cells=carveMaze(world.cols,world.rows);
      buildWallsFromCells(cells, new THREE.MeshStandardMaterial({ color:0x9aa4b2, roughness:0.95 }));

      captureGroup.clear();
      function addCapturePoint(x, z, label){
        const geo = new THREE.CylinderGeometry(2, 2, 0.4, 24);
        const mat = new THREE.MeshStandardMaterial({ color:0x38bdf8, transparent:true, opacity:0.5 });
        const cap = new THREE.Mesh(geo, mat);
        cap.position.set(x, 0.2, z);
        captureGroup.add(cap);

        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 40px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, 32, 32);
        const tex = new THREE.CanvasTexture(canvas);

        const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent:true });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.position.set(x, 2.5, z);
        sprite.scale.set(2,2,1);
        captureGroup.add(sprite);
      }

      addCapturePoint(0,0,'A');
      addCapturePoint(worldSizeX/3,0,'B');
      addCapturePoint(-worldSizeX/3,0,'C');
    }

    buildMapDOM();
  </script>
</body>
</html>
