"""
This file was generated by Copilot to make the app Render-ready.
"""

'use strict';

// --- 기본 의존성 ---
const path = require('path');
const express = require('express');
const http = require('http');
const WebSocket = require('ws');

// --- Render/프로덕션 환경 설정 ---
const PORT = parseInt(process.env.PORT, 10) || 8080; // Render는 PORT를 주입(기본 10000). 로컬은 8080 사용.

// 허용 오리진(쉼표로 구분). 예: https://mygame.onrender.com,https://www.example.com
const ALLOWED_ORIGINS = (process.env.ALLOWED_ORIGINS || '').split(',')
  .map(s => s.trim()).filter(Boolean);

// --- Express: 정적 파일/헬스 체크 ---
const app = express();

app.use(express.static(path.join(__dirname), {
  setHeaders(res, filePath) {
    if (filePath.endsWith('index.html')) {
      res.setHeader('Cache-Control', 'no-store');
    } else {
      res.setHeader('Cache-Control', 'public, max-age=3600');
    }
  }
}));

app.get('/healthz', (req, res) => {
  res.status(200).send('ok');
});

// --- HTTP 서버 & WebSocket 서버 생성 ---
const server = http.createServer(app);

const wss = new WebSocket.Server({
  server,
  path: '/ws',
  clientTracking: true,
  maxPayload: 64 * 1024,
  perMessageDeflate: {
    zlibDeflateOptions: { chunkSize: 1024 },
    zlibInflateOptions: { chunkSize: 1024 },
    clientNoContextTakeover: true,
    serverNoContextTakeover: true,
    serverMaxWindowBits: 10
  }
});

// --- 유틸 & 게임 상태(기존 로직 유지) ---
const rooms = new Map();
function now() { return Date.now(); }
function mmss(sec) { const m = Math.floor(sec/60); const s = Math.floor(sec%60); return `${m}:${s.toString().padStart(2,'0')}`; }
function rid() { return Math.random().toString(36).slice(2, 10); }
function defaultSettings() { return { dm: { kills: 20, minutes: 10 }, dom: { score: 150, minutes: 10 } }; }

function broadcast(room, msg) {
  const s = JSON.stringify(msg);
  for (const [, c] of room.clients) {
    if (c.ws.readyState === WebSocket.OPEN) {
      try { c.ws.send(s); } catch {}
    }
  }
}

function roomState(room) {
  const players = [];
  for (const [id, c] of room.clients) {
    players.push({ id, pos: c.pos, color: c.color, hp: c.hp });
  }
  const kills = {};
  for (const [id, c] of room.clients) kills[id] = c.kills || 0;
  return {
    type: 'state',
    players,
    time: mmss(room.timeLeft),
    scoreBlue: room.scoreBlue || 0,
    scoreRed: room.scoreRed || 0,
    points: room.points?.map(p => ({ name: p.name, progress: p.progress })) || [],
    kills
  };
}

function setMode(room, mode) {
  room.mode = (mode === 'dom' ? 'dom' : 'dm');
  broadcast(room, { type: 'mode', mode: room.mode });
}

function startMatch(room) {
  room.started = true;
  room.timeLeft = (room.mode === 'dm' ? room.settings.dm.minutes : room.settings.dom.minutes) * 60;
  room.scoreBlue = 0; room.scoreRed = 0;
  room.points = (room.mode === 'dom')
    ? [{ name: 'A', owner: 'neutral', progress: 0 }, { name: 'B', owner: 'neutral', progress: 0 }, { name: 'C', owner: 'neutral', progress: 0 }]
    : [];
  for (const c of room.clients.values()) { c.hp = 100; c.kills = 0; }
  broadcast(room, { type: 'start', mode: room.mode, settings: room.settings });
}

function checkVictory(room) {
  if (room.mode === 'dm') {
    for (const [, c] of room.clients) {
      if ((c.kills || 0) >= room.settings.dm.kills) {
        broadcast(room, { type: 'victory', text: `DEATHMATCH 종료 - ${c.name} 승리!` });
        room.started = false; return true;
      }
    }
  } else {
    if ((room.scoreBlue || 0) >= room.settings.dom.score) {
      broadcast(room, { type: 'victory', text: `DOMINATION 종료 - BLUE 승리!` });
      room.started = false; return true;
    }
    if ((room.scoreRed || 0) >= room.settings.dom.score) {
      broadcast(room, { type: 'victory', text: `DOMINATION 종료 - RED 승리!` });
      room.started = false; return true;
    }
  }
  if (room.timeLeft <= 0) {
    broadcast(room, { type: 'victory', text: `시간 종료!` });
    room.started = false; return true;
  }
  return false;
}

function tick() {
  for (const room of rooms.values()) {
    if (!room.started) continue;
    room.timeLeft = Math.max(0, room.timeLeft - 0.2); // 5Hz

    room._acc = (room._acc || 0) + 0.2;
    if (room._acc >= 1) {
      room._acc = 0;
      if (room.mode === 'dom') {
        let blue = 0, red = 0;
        for (const p of room.points) {
          if (p.owner === 'blue') blue++;
          else if (p.owner === 'red') red++;
        }
        room.scoreBlue += blue;
        room.scoreRed += red;
      }
    }

    if (checkVictory(room)) continue;
    broadcast(room, roomState(room));
  }
}
setInterval(tick, 200);

function getIP(req) {
  const xf = req.headers['x-forwarded-for'];
  if (typeof xf === 'string') return xf.split(',')[0].trim();
  return req.socket?.remoteAddress || 'unknown';
}

function heartbeat() { this.isAlive = true; }
const hbInterval = setInterval(() => {
  wss.clients.forEach(ws => {
    if (ws.isAlive === false) return ws.terminate();
    ws.isAlive = false;
    try { ws.ping(); } catch {}
  });
}, 30000);

wss.on('close', () => clearInterval(hbInterval));

wss.on('connection', (ws, req) => {
  const origin = req.headers.origin;
  if (ALLOWED_ORIGINS.length && origin && !ALLOWED_ORIGINS.includes(origin)) {
    try { ws.close(1008, 'origin not allowed'); } catch {}
    return;
  }

  ws.isAlive = true;
  ws.on('pong', heartbeat);

  const clientId = rid();
  let joinedCode = null;

  ws.on('message', (data) => {
    if (typeof data !== 'string' && !Buffer.isBuffer(data)) return;
    let m; try { m = JSON.parse(data.toString()); } catch { return; }

    if (m.type === 'createRoom') {
      const code = ((m.code || '').toUpperCase().slice(0, 6)) || ('ROOM' + Math.floor(Math.random() * 999));
      const name = m.name || 'Room';
      const room = { name, mode: 'dm', settings: defaultSettings(), hostId: clientId, clients: new Map(), started: false };
      rooms.set(code, room);
      room.clients.set(clientId, { ws, name: m.player?.name || 'Player', color: m.player?.color || '#3b82f6', pos: { x: 0, y: 1.8, z: 0 }, hp: 100, kills: 0 });
      joinedCode = code;
      ws.send(JSON.stringify({ type: 'roomCreated', code, name, clientId }));
      broadcast(room, { type: 'lobby', text: `${room.name} (${code}) - 인원 ${room.clients.size}명` });
    }
    else if (m.type === 'joinRoom') {
      const code = (m.code || '').toUpperCase();
      const room = rooms.get(code);
      if (!room) { ws.send(JSON.stringify({ type: 'lobby', text: '방이 존재하지 않습니다.' })); return; }
      room.clients.set(clientId, { ws, name: m.player?.name || 'Player', color: m.player?.color || '#3b82f6', pos: { x: 0, y: 1.8, z: 0 }, hp: 100, kills: 0 });
      joinedCode = code;
      ws.send(JSON.stringify({ type: 'roomJoined', code, name: room.name, clientId, mode: room.mode, settings: room.settings }));
      broadcast(room, { type: 'lobby', text: `${room.name} (${code}) - 인원 ${room.clients.size}명` });
    }
    else if (m.type === 'setMode') {
      const room = rooms.get(m.code); if (!room || room.hostId !== clientId) return; setMode(room, m.mode);
    }
    else if (m.type === 'setSettings') {
      const room = rooms.get(m.code); if (!room || room.hostId !== clientId) return; room.settings = m.settings || room.settings; broadcast(room, { type: 'settings', settings: room.settings });
    }
    else if (m.type === 'startGame') {
      const room = rooms.get(m.code); if (!room || room.hostId !== clientId) return; startMatch(room);
    }
    else if (m.type === 'spawn') {
      const room = rooms.get(m.code); if (!room) return; const c = room.clients.get(clientId); if (!c) return; c.pos = m.pos || c.pos; c.color = m.color || c.color;
    }
    else if (m.type === 'move') {
      const room = rooms.get(m.code); if (!room) return; const c = room.clients.get(clientId); if (!c) return; c.pos = m.pos || c.pos;
    }
    else if (m.type === 'shoot') {
      const room = rooms.get(m.code); if (!room) return; broadcast(room, { type: 'shoot', id: clientId });
    }
    else if (m.type === 'hit') {
      const room = rooms.get(m.code); if (!room) return; const target = room.clients.get(m.to); const from = room.clients.get(clientId); if (!target || !from) return; if (!room.started) return;
      const damage = 34; target.hp = Math.max(0, (target.hp || 100) - damage);
      broadcast(room, { type: 'hit', from: clientId, to: m.to });
      if (target.hp <= 0) { from.kills = (from.kills || 0) + 1; target.hp = 100; target.pos = { x: 0, y: 1.8, z: 0 }; }
    }
    else if (m.type === 'requestRebuild') {
      const room = rooms.get(m.code); if (!room) return; broadcast(room, { type: 'lobby', text: `맵 리빌드 요청됨` });
    }
  });

  ws.on('close', () => {
    if (!joinedCode) return; const room = rooms.get(joinedCode); if (!room) return; room.clients.delete(clientId);
    broadcast(room, { type: 'lobby', text: `${room.name} (${joinedCode}) - 인원 ${room.clients.size}명` });
    if (room.clients.size === 0) rooms.delete(joinedCode);
  });

  console.log(`[WS] connected ip=${getIP(req)} id=${clientId} origin=${origin || 'n/a'}`);
});

server.listen(PORT, '0.0.0.0', () => {
  console.log(`Block FPS Online listening on http://0.0.0.0:${PORT} (ws path: /ws)`);
});
